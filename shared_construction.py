from typing import List

def shared_construction(nums: List) -> None:
    """
    1) Описание алгоритма с доказательством корректности:
    Сначала считаем сумму, потом проходимся по каждому элементу и находим процент
    Также умножаем на 0.01,округляем до 3 знаков и используем :.3f, чтобы следовать формату вывода как в задаче
    Алгоритм корректен, потому что он точно следует определению процентного отношения.

    2) Алгоритм имеет линейную сложность O(N), где N — количество долей.
    Память требуется для хранения массива долей (O(N)) и параметра sum_nums - (O(1)).
    Таким образом, общее потребление памяти — O(N).

    3)Ограничения на размер входных параметров:
    Алгоритм будет работать эффективно для относительно больших значений N.
    C учетом миллисекунд на операцию, можно предположить,
    что для N порядка 10^6 алгоритм выполнится за разумное время

    4)Субъективная оценка
    Субъективная сложность задачи: 2/10. Задача достаточно простая,
    требующая базовых знаний программирования и работы с массивами.
    Реализация не занимает много времени. Затраченное время на реализацию —
    примерно 15 минут (включая написание этого объяснения).
    :param nums: Элементы долей в последовательности
    :return: None
    """
    sum_nums =  sum(nums)
    for num in nums:
        percent = round((num / sum_nums) * 100 * 0.01, 3)
        print(f"{percent:.3f}")


if __name__ == "__main__":
    l = input()
    nums = [float(input()) for _ in range(int(l))]
    print(shared_construction(nums))